language js

// Ban imperative error handling patterns in Effect contexts
// Effect provides typed, composable error handling via Effect.fail/tryPromise/catchAll
// Enforcement: error level (blocks imperative error patterns in Effect code)
//
// Patterns matched:
// - await, Promise.then, new Promise, Promise.all inside Effect.gen
// - throw statements in Effect.gen or Effect.sync
// - try-catch inside Effect.gen or around Effect runners
//
// Rationale:
// - Effect tracks errors in the type system (Effect<A, E, R>)
// - Imperative patterns (Promise/throw/try-catch) bypass Effect's type-safe error tracking
// - Using Promise primitives breaks Effect's dependency injection and error channel
// - throw statements create untyped errors that can't be caught with Effect.catchTag
// - try-catch converts typed Effect errors to untyped exceptions
// - Untyped errors become uncaught promise rejections
//
// Effect-safe alternatives:
//
// For Promises:
// 1. Use Effect.tryPromise() for async operations with typed error handling
// 2. Use Effect.all() for parallel Promise composition
// 3. Use Effect.promise() for infallible Promises
//
// For Error Throwing:
// 1. Use Effect.fail() for expected errors (typed)
// 2. Use Effect.die() for unexpected defects (untyped)
// 3. Use Effect.try() instead of Effect.sync() when operations may throw
//
// For Try-Catch:
// 1. Use Effect.catchAll() to handle all error types
// 2. Use Effect.catchTag() to handle specific error types
// 3. Use Effect.match() or Effect.either() for Effect runners
//
// Example fixes:
//
// ❌ WRONG: Using Promise primitives in Effect.gen
// Effect.gen(function* () {
//   const data = await fetch(url);           // Breaks Effect error tracking
//   const results = Promise.all([p1, p2]);   // Bypasses Effect composition
// })
//
// ✅ CORRECT: Use Effect.tryPromise and Effect.all
// Effect.gen(function* () {
//   const data = yield* Effect.tryPromise({
//     try: () => fetch(url),
//     catch: (e) => new FetchError({ cause: e })
//   });
//   const results = yield* Effect.all([e1, e2]);
// })
//
// ❌ WRONG: Using throw in Effect.gen
// Effect.gen(function* () {
//   throw new Error("Something went wrong");  // Untyped error
// })
//
// ✅ CORRECT: Use Effect.fail for typed errors
// Effect.gen(function* () {
//   yield* Effect.fail(new MyError({ message: "Something went wrong" }));
// })
//
// ❌ WRONG: Using try-catch in Effect.gen
// Effect.gen(function* () {
//   try {
//     yield* riskyOperation();
//   } catch (e) {
//     // Loses Effect error types
//   }
// })
//
// ✅ CORRECT: Use Effect.catchTag for typed error handling
// Effect.gen(function* () {
//   yield* riskyOperation();
// }).pipe(
//   Effect.catchTag("NetworkError", (e) => Effect.succeed(fallbackValue))
// )

or {
  // Pattern 1: await in Effect.gen
  `Effect.gen(function* () { $body })` where {
    $body <: contains $stmt where {
      $stmt <: `await $expr`,
      register_diagnostic(
        span = $stmt,
        message = "Do not use await inside Effect.gen. Use yield* Effect.tryPromise() for async ops. See docs/LINTING_POLICY.md for Effect error handling.",
        severity = "error"
      )
    }
  },

  // Pattern 2: throw statements in Effect.gen
  `Effect.gen(function* () { $body })` where {
    $body <: contains $stmt where {
      $stmt <: `throw $error`,
      register_diagnostic(
        span = $stmt,
        message = "Do not throw in Effect.gen. Use yield* Effect.fail() for typed errors or Effect.die() for defects. See docs/LINTING_POLICY.md for alternatives.",
        severity = "error"
      )
    }
  },

  // Pattern 3: throw statements in Effect.sync
  `Effect.sync(() => { $body })` where {
    $body <: contains $stmt where {
      $stmt <: `throw $error`,
      register_diagnostic(
        span = $stmt,
        message = "Do not throw in Effect.sync. Use Effect.try() for operations that may throw, or yield* Effect.fail() for typed errors. See docs/LINTING_POLICY.md for guidance.",
        severity = "error"
      )
    }
  },

  // Pattern 4: try-catch inside Effect.gen
  `Effect.gen(function* () { $body })` where {
    $body <: contains $stmt where {
      $stmt <: `try { $tryBody } catch ($err) { $catchBody }`,
      register_diagnostic(
        span = $stmt,
        message = "Do not use try-catch inside Effect.gen. Use Effect.catchAll(), Effect.catchTag(), or Effect.tapError() for typed error handling. See docs/LINTING_POLICY.md for patterns.",
        severity = "error"
      )
    }
  },

  // Pattern 5: try-catch around Effect runners
  $stmt where {
    $stmt <: `try { $body } catch ($err) { $catchBody }`,
    $body <: contains or { `Effect.runPromise`, `Effect.runSync` },
    register_diagnostic(
      span = $stmt,
      message = "Do not wrap Effect runners in try-catch. Use Effect.match() or Effect.either() to handle errors before running. See docs/LINTING_POLICY.md for examples.",
      severity = "error"
    )
  }
}
